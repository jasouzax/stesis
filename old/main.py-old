import cv2
import numpy as np
import sys
import json
import math
from config import CAM_ID_LEFT, CAM_ID_RIGHT, BASELINE, MIN_DISPARITY, NUM_DISPARITIES, BLOCK_SIZE

# --- CONFIGURATION FOR VNC ---
DISPLAY_SCALE = 0.5  # 0.5 = 50% size. Adjust this to make it smaller/larger.
# -----------------------------

def update_params(val):
    pass # Callback for trackbars

def load_calibration(baseline_cm):
    """ Loads the calibration data for a specific baseline """
    filename = f"stereo-{baseline_cm}.json"
    meta_filename = "stereo.json"

    try:
        with open(filename, 'r') as f:
            data = json.load(f)

        pixel_error = data.get("pixel_error", None)

        if pixel_error is None:
            pixel_error = "N/A"
            try:
                with open(meta_filename, 'r') as f:
                    meta = json.load(f)
                    if meta.get("file") == filename or meta.get("file") == filename.split('/')[-1]:
                        pixel_error = meta.get("pixel_error", "N/A")
            except FileNotFoundError:
                pass

        return data, pixel_error
    except FileNotFoundError:
        print(f"Error: Calibration file '{filename}' not found.")
        print("Please run 'calibrate.py' first.")
        sys.exit(1)

def draw_radar(disparity_map, width, height, max_disp, focal_length, baseline_cm, scan_x):
    """
    Draws a Top-Down Radar view.
    """
    radar_h = 300
    radar_img = np.zeros((radar_h, width, 3), dtype=np.uint8)
    
    center_x = width // 2
    center_y = radar_h - 10 
    
    px_per_cm = radar_h / 400.0
    
    for dist_cm in [100, 200, 300]:
        radius = int(dist_cm * px_per_cm)
        cv2.ellipse(radar_img, (center_x, center_y), (radius, radius), 0, 180, 360, (50, 50, 50), 1)
        cv2.putText(radar_img, f"{dist_cm/100}m", (center_x + 5, center_y - radius - 5), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.4, (100, 100, 100), 1)

    col_max_disp = cv2.reduce(disparity_map, 0, cv2.REDUCE_MAX).flatten()
    valid_mask = col_max_disp > MIN_DISPARITY
    indices = np.where(valid_mask)[0]
    
    for x in indices:
        d = col_max_disp[x]
        if d <= 0: continue

        real_disp = d / 16.0
        if real_disp < 1.0: continue
        
        depth_cm = (focal_length * baseline_cm) / real_disp
        
        if depth_cm > 400: continue

        angle_deg = 60 - (x / width) * 120
        angle_rad = math.radians(angle_deg)
        
        r_px = depth_cm * px_per_cm
        
        rx = int(center_x + r_px * math.sin(angle_rad))
        ry = int(center_y - r_px * math.cos(angle_rad))
        
        norm_dist = min(depth_cm / 300.0, 1.0)
        b = 0
        g = int(255 * norm_dist)
        r = int(255 * (1 - norm_dist))
        
        cv2.circle(radar_img, (rx, ry), 2, (b, g, r), -1)

    sweep_angle_deg = 60 - (scan_x / width) * 120
    sweep_rad = math.radians(sweep_angle_deg)
    
    line_len = radar_h - 20
    lx = int(center_x + line_len * math.sin(sweep_rad))
    ly = int(center_y - line_len * math.cos(sweep_rad))
    cv2.line(radar_img, (center_x, center_y), (lx, ly), (0, 255, 0), 2)
    
    cv2.rectangle(radar_img, (0,0), (width, radar_h), (100, 100, 100), 2)
    cv2.putText(radar_img, "RADAR (Top Down)", (10, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

    return radar_img

def main():
    calib_data, pixel_error = load_calibration(BASELINE)

    M1 = np.array(calib_data["M1"])
    d1 = np.array(calib_data["d1"])
    M2 = np.array(calib_data["M2"])
    d2 = np.array(calib_data["d2"])
    R1 = np.array(calib_data["R1"])
    P1 = np.array(calib_data["P1"])
    R2 = np.array(calib_data["R2"])
    P2 = np.array(calib_data["P2"])
    
    focal_length = P1[0][0] 

    width = int(calib_data["width"])
    height = int(calib_data["height"])

    cap_l = cv2.VideoCapture(CAM_ID_LEFT)
    cap_r = cv2.VideoCapture(CAM_ID_RIGHT)

    # Low Latency Settings
    cap_l.set(cv2.CAP_PROP_BUFFERSIZE, 1)
    cap_r.set(cv2.CAP_PROP_BUFFERSIZE, 1)

    if not cap_l.isOpened() or not cap_r.isOpened():
        print("Error: Cameras not found.")
        sys.exit()

    map1_l, map2_l = cv2.initUndistortRectifyMap(M1, d1, R1, P1, (width, height), cv2.CV_16SC2)
    map1_r, map2_r = cv2.initUndistortRectifyMap(M2, d2, R2, P2, (width, height), cv2.CV_16SC2)

    stereo = cv2.StereoSGBM_create(
        minDisparity=MIN_DISPARITY,
        numDisparities=NUM_DISPARITIES,
        blockSize=BLOCK_SIZE,
        P1=8 * 3 * BLOCK_SIZE**2,
        P2=32 * 3 * BLOCK_SIZE**2,
        disp12MaxDiff=1,
        uniquenessRatio=10,
        speckleWindowSize=100,
        speckleRange=32,
        mode=cv2.STEREO_SGBM_MODE_SGBM_3WAY
    )

    wls_filter = None
    right_matcher = None
    try:
        right_matcher = cv2.ximgproc.createRightMatcher(stereo)
        wls_filter = cv2.ximgproc.createDisparityWLSFilter(matcher_left=stereo)
        wls_filter.setLambda(8000.0)
        wls_filter.setSigmaColor(1.5)
        print("WLS Filter: ENABLED")
    except AttributeError:
        print("WLS Filter: DISABLED")

    cv2.namedWindow("Stesis Interface")
    cv2.createTrackbar("Num Disparities (16x)", "Stesis Interface", 6, 16, update_params)
    cv2.createTrackbar("Block Size", "Stesis Interface", 5, 50, update_params)

    print(f"--- Stesis Radar Mode ---")
    print(f"Display Scale: {DISPLAY_SCALE*100}%")
    print("Press 'Q' to quit.")

    scan_line_x = 0 
    scan_speed = 15

    while True:
        ret_l, frame_l = cap_l.read()
        ret_r, frame_r = cap_r.read()

        if not ret_l or not ret_r: break
        frame_r = cv2.rotate(frame_r, cv2.ROTATE_180)

        rect_l = cv2.remap(frame_l, map1_l, map2_l, cv2.INTER_LINEAR)
        rect_r = cv2.remap(frame_r, map1_r, map2_r, cv2.INTER_LINEAR)

        num_disp = cv2.getTrackbarPos("Num Disparities (16x)", "Stesis Interface") * 16
        if num_disp < 16: num_disp = 16
        blk = cv2.getTrackbarPos("Block Size", "Stesis Interface")
        if blk % 2 == 0: blk += 1
        if blk < 5: blk = 5
        
        stereo.setNumDisparities(num_disp)
        stereo.setBlockSize(blk)
        if right_matcher:
            right_matcher.setNumDisparities(num_disp)
            right_matcher.setBlockSize(blk)

        gray_l = cv2.cvtColor(rect_l, cv2.COLOR_BGR2GRAY)
        gray_r = cv2.cvtColor(rect_r, cv2.COLOR_BGR2GRAY)

        if wls_filter:
            disp_l = stereo.compute(gray_l, gray_r)
            disp_r = right_matcher.compute(gray_r, gray_l)
            disp_filtered = wls_filter.filter(disp_l, gray_l, disparity_map_right=disp_r, right_view=gray_r)
            disparity = disp_filtered
        else:
            disparity = stereo.compute(gray_l, gray_r)

        # --- VISUALIZATION PREP ---
        disp_f = disparity.astype(np.float32) / 16.0
        disp_vis = (disp_f - MIN_DISPARITY) / num_disp
        disp_vis = (disp_vis * 255).astype(np.uint8)
        disp_color = cv2.applyColorMap(disp_vis, cv2.COLORMAP_JET)

        scan_line_x = (scan_line_x + scan_speed) % width
        
        # Draw Scan Line
        cv2.line(disp_color, (scan_line_x, 0), (scan_line_x, height), (0, 255, 0), 2)
        
        # Generate Radar (Full Size first for accuracy)
        radar_view = draw_radar(disparity, width, height, num_disp * 16, focal_length, BASELINE, scan_line_x)

        # --- SCALING FOR DISPLAY ---
        # 1. Resize the top two images (Input + Depth)
        display_w = int(width * DISPLAY_SCALE)
        display_h = int(height * DISPLAY_SCALE)
        
        rect_l_small = cv2.resize(rect_l, (display_w, display_h))
        disp_color_small = cv2.resize(disp_color, (display_w, display_h))
        
        # Stack Top Row
        top_row = np.hstack((rect_l_small, disp_color_small))
        
        # 2. Resize Radar to match the total width of the top row
        # Top row total width = display_w * 2
        # Radar original aspect ratio needs to be maintained roughly, or just fit to width
        radar_target_w = display_w * 2
        radar_target_h = int(300 * DISPLAY_SCALE) # Scale height similarly
        
        radar_small = cv2.resize(radar_view, (radar_target_w, radar_target_h))

        # 3. Final Stack
        final_layout = np.vstack((top_row, radar_small))

        cv2.imshow("Stesis Interface", final_layout)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cap_l.release()
    cap_r.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
